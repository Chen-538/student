<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>戰術迷宮：極速落子｜生成式 AI 戰略棋盤遊戲</title>
<style>
  :root {
    --bg:#050816;
    --panel:#020617;
    --panel-soft:#0b1220;
    --accent-blue:#38bdf8;
    --accent-red:#fb7185;
    --text:#e0e7ff;
  }
  * { box-sizing:border-box; }
  body { 
    margin:0;
    background:radial-gradient(circle at top,#1f2937 0,#020617 45%,#000 100%);
    color:var(--text);
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif; 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    padding:16px;
  }
  a { color:var(--accent-blue); text-decoration:none; }
  a:hover { text-decoration:underline; }

  header {
    width:100%;
    max-width:980px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:10px 18px;
    border-radius:999px;
    background:linear-gradient(90deg,#020617,#111827);
    box-shadow:0 16px 40px rgba(15,23,42,.9);
    margin-bottom:18px;
  }
  header .logo { font-weight:700; letter-spacing:2px; font-size:15px; }
  header nav { display:flex; gap:14px; font-size:14px; }
  header button.nav-btn {
    border:none;
    background:transparent;
    color:var(--text);
    cursor:pointer;
    padding:6px 10px;
    border-radius:999px;
  }
  header button.nav-btn.active {
    background:rgba(56,189,248,.25);
  }

  main { width:100%; max-width:980px; }
  section { margin-bottom:26px; padding:16px 18px; border-radius:24px; background:rgba(15,23,42,.9); box-shadow:0 18px 40px rgba(15,23,42,.9); }

  #home h1 { margin:0 0 8px; font-size:24px; letter-spacing:2px; }
  #home p.lead { opacity:.9; margin-top:4px; }
  #home ul { padding-left:20px; margin-top:8px; line-height:1.6; }
  #home .cta-row { margin-top:12px; display:flex; flex-wrap:wrap; gap:10px; }
  #home .cta-row button { padding:8px 16px; border:none; border-radius:999px; cursor:pointer; font-weight:600; font-size:14px; }
  #home .primary { background:var(--accent-blue); color:#020617; box-shadow:0 14px 32px rgba(56,189,248,.5); }
  #home .secondary { background:transparent; border:1px solid rgba(148,163,184,.8); color:var(--text); }

  #rules h2, #game-section h2 { margin-top:0; }
  #rules ul { padding-left:20px; line-height:1.7; }

  #game-layout { display:flex; flex-direction:column; gap:14px; }

  #game-top { display:flex; flex-wrap:wrap; gap:14px; align-items:center; justify-content:space-between; }

  #status-bar { 
    display:flex; 
    gap:12px; 
    align-items:center; 
    padding:8px 14px; 
    border-radius:999px; 
    background:linear-gradient(90deg,#1f2937,#020617);
    box-shadow:0 0 24px rgba(59,130,246,.35);
    font-size:14px;
  }
  #timer { font-weight:600; }
  #start-btn {
    border:none;
    border-radius:999px;
    padding:4px 10px;
    background:var(--accent-blue);
    color:#020617;
    cursor:pointer;
    font-size:13px;
    font-weight:600;
  }
  #mode-select { background:#020617; color:var(--text); border-radius:999px; border:1px solid rgba(148,163,184,.7); padding:4px 10px; }

  #board-wrapper { display:flex; justify-content:center; margin-top:4px; }
  #board-3d { 
    transition: transform .35s ease-in-out; 
    transform:rotate(0deg);
  }

  #board { 
    display:grid; 
    grid-template-columns: repeat(10, 52px); 
    grid-template-rows: repeat(10, 52px); 
    gap:3px; 
    margin-top:10px; 
    padding:12px; 
    border-radius:24px; 
    background:radial-gradient(circle at top,#1f2937,#020617);
    box-shadow:0 18px 45px rgba(15,23,42,.9);
  }
  .cell { 
    width:52px; 
    height:52px; 
    background:#020617; 
    display:flex; 
    justify-content:center; 
    align-items:center; 
    cursor:pointer; 
    border-radius:16px; 
    font-size:22px; 
    box-shadow:0 0 0 1px rgba(148,163,184,.35) inset;
    transition:box-shadow .15s, background .15s;
    position:relative;
    overflow:visible;
  }
  #board .cell:hover:not(.blocked) { 
    box-shadow:0 0 0 1px rgba(129,140,248,.9) inset, 0 8px 14px rgba(15,23,42,.9);
  }

  .p1 { background:var(--accent-blue); box-shadow:0 0 0 2px #0ea5e9 inset; }
  .p2 { background:var(--accent-red); box-shadow:0 0 0 2px #f97316 inset; }
  .blocked { background:#4b5563; box-shadow:0 0 0 2px #9ca3af inset; cursor:not-allowed; }
  .drop { animation:pieceDrop .35s ease-out; }

  #controls-wrapper { display:flex; flex-wrap:wrap; gap:14px; justify-content:space-between; }
  .player-panel {
    flex:1 1 260px;
    min-width:230px;
    padding:10px 12px;
    border-radius:18px;
    background:linear-gradient(145deg,#020617,#111827);
    box-shadow:0 14px 30px rgba(15,23,42,.9);
    font-size:13px;
  }
  .player-panel h3 { margin:0 0 6px; display:flex; justify-content:space-between; align-items:center; font-size:14px; }
  .pill { padding:2px 8px; border-radius:999px; font-size:11px; opacity:.85; }
  .pill.p1 { background:rgba(56,189,248,.18); }
  .pill.p2 { background:rgba(251,113,133,.18); }
  .pill.ai { background:rgba(52,211,153,.18); }
  .skill-row { display:flex; flex-direction:column; gap:6px; margin-top:4px; }
  button.skill {
    padding:6px 10px;
    border:none;
    border-radius:999px;
    cursor:pointer;
    font-size:13px;
    text-align:left;
    display:flex;
    justify-content:space-between;
    align-items:center;
  }
  .skill-label { font-weight:500; }
  .skill-count { font-size:12px; opacity:.9; }
  .skill.p1-btn { background:rgba(56,189,248,.15); color:#e0f2fe; }
  .skill.p2-btn { background:rgba(251,113,133,.15); color:#ffe4e6; }
  button.skill:disabled { opacity:.35; cursor:not-allowed; box-shadow:none; }

  #hint { margin-top:6px; font-size:12px; opacity:.85; }

  #actions { margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
  #actions button {
    padding:7px 14px;
    border:none;
    background:var(--accent-blue);
    color:#020617;
    border-radius:999px;
    cursor:pointer;
    font-size:14px;
    font-weight:600;
    box-shadow:0 12px 28px rgba(56,189,248,.4);
  }
  #actions button:hover { filter:brightness(1.08); }

  #stats { margin-top:8px; font-size:13px; opacity:.9; }

  @keyframes pieceDrop {
    0% { transform:translateY(-90px) scale(0.4); }
    75% { transform:translateY(6px) scale(1.03); }
    100% { transform:translateY(0) scale(1); }
  }

  @media (max-width:800px) {
    #board { transform:scale(.9); }
  }
  @media (max-width:650px) {
    #board { transform:scale(.8); }
  }
  @media (max-width:520px) {
    #board { transform:scale(.7); }
  }
</style>
</head>
<body>
<header>
  <div class="logo">戰術迷宮：極速落子</div>
  <nav>
    <button class="nav-btn active" onclick="scrollToSection('home')">首頁</button>
    <button class="nav-btn" onclick="scrollToSection('rules')">規則介紹</button>
    <button class="nav-btn" onclick="scrollToSection('game-section')">開始遊戲</button>
  </nav>
</header>

<main>
  <section id="home">
    <h1>生成式 AI × 旋轉重力五子棋</h1>
    <p class="lead">
      在 10×10 戰術棋盤上，以極速思考、旋轉牌與主動技能決勝負。  
      雙方各下完一次算一回合，每三回合棋盤會依目前方向自動旋轉 90°，並把所有棋子往新的「下方」推到能落下的位置。
    </p>
    <ul>
      <li>雙人或對 AI 對戰，規則直覺、入門快速。</li>
      <li>每手 15 秒極速計時，但時間到會自動幫你隨機落子，不會直接判負。</li>
      <li>主動技能：連續落子、封鎖格子、移除對手棋子、旋轉棋盤牌。</li>
      <li>每人每回合最多使用一張技能牌，考驗卡牌 timing 與心機。</li>
      <li>每滿三回合自動旋轉＋重力往下，局勢隨時大翻盤。</li>
      <li>內建戰績紀錄：勝場數、總對戰數與最長連勝紀錄。</li>
    </ul>
    <div class="cta-row">
      <button class="primary" onclick="scrollToSection('game-section')">▶ 立即開始對戰</button>
      <button class="secondary" onclick="scrollToSection('rules')">查看詳細規則</button>
    </div>
  </section>

  <section id="rules">
    <h2>規則介紹</h2>
    <ul>
      <li><strong>勝利條件：</strong>先在棋盤上連成任意方向五顆同色棋子（直線、橫線或斜線）者獲勝。</li>
      <li><strong>回合定義：</strong>雙方玩家各下完一次棋，算作 1 回合。</li>
      <li><strong>自動旋轉：</strong>每經過 3 回合，棋盤會依目前設定方向自動旋轉 90°，並在新方向的重力之下，棋盤上的所有棋子會沿著新「下方」方向落到底（中途若遇到棋子或障礙就停）。</li>
      <li><strong>旋轉牌：</strong>每名玩家在初始時各獲得 1 張「旋轉棋盤」技能牌，可在自己的回合使用一次：
        <ul>
          <li>使用時選擇「順時針」或「逆時針」旋轉 90°，立刻生效並套用重力落到底。</li>
          <li>之後每 3 回合的自動旋轉，會沿用最後使用旋轉牌的那位玩家所選的方向。</li>
          <li>直到另一位玩家使用自己的旋轉牌後，才可能改變自動旋轉方向。</li>
        </ul>
      </li>
      <li><strong>技能限制：</strong>每一回合中，每位玩家<strong>最多只能使用 1 張技能牌</strong>（連續落子 / 封鎖格子 / 移除棋子 / 旋轉牌都算）。</li>
      <li><strong>回合計時：</strong>每位玩家每一手有 15 秒思考時間，時間歸零仍未落子時，系統會自動替該玩家在隨機合法位置落子，而不是直接判負。</li>
      <li><strong>其他技能使用方式：</strong>輪到你的回合時，可先點選技能按鈕，再在棋盤上點選對應格子發動效果。</li>
    </ul>
  </section>

  <section id="game-section">
    <h2>實際遊戲區</h2>
    <div id="game-layout">
      <div id="game-top">
        <div id="status-bar">
          <div id="turn">輪到：玩家 1（藍）</div>
          <div id="timer">尚未開始：請按「開始遊戲」</div>
          <button id="start-btn" onclick="startGame()">開始遊戲</button>
        </div>
        <div>
          <label for="mode-select">對戰模式：</label>
          <select id="mode-select" onchange="changeMode(this.value)">
            <option value="pvp">雙人對戰</option>
            <option value="ai">對 AI 對戰（你是玩家 1）</option>
          </select>
        </div>
      </div>

      <div id="board-wrapper">
        <div id="board-3d">
          <div id="board"></div>
        </div>
      </div>

      <div id="controls-wrapper">
        <div class="player-panel" id="panel-p1">
          <h3>玩家 1 技能 <span class="pill p1">藍方</span></h3>
          <div class="skill-row">
            <button id="p1-double" class="skill p1-btn" onclick="useSkill(1,'double')">
              <span class="skill-label">連續落子</span>
              <span class="skill-count" id="p1-double-count">x1</span>
            </button>
            <button id="p1-block" class="skill p1-btn" onclick="useSkill(1,'block')">
              <span class="skill-label">封鎖格子</span>
              <span class="skill-count" id="p1-block-count">x1</span>
            </button>
            <button id="p1-remove" class="skill p1-btn" onclick="useSkill(1,'remove')">
              <span class="skill-label">移除對方棋子</span>
              <span class="skill-count" id="p1-remove-count">x1</span>
            </button>
            <button id="p1-rotate" class="skill p1-btn" onclick="useRotateSkill(1)">
              <span class="skill-label">旋轉棋盤牌</span>
              <span class="skill-count" id="p1-rotate-count">x1</span>
            </button>
          </div>
        </div>

        <div class="player-panel" id="panel-p2">
          <h3>玩家 2 技能 <span class="pill p2" id="p2-tag">紅方</span></h3>
          <div class="skill-row">
            <button id="p2-double" class="skill p2-btn" onclick="useSkill(2,'double')">
              <span class="skill-label">連續落子</span>
              <span class="skill-count" id="p2-double-count">x1</span>
            </button>
            <button id="p2-block" class="skill p2-btn" onclick="useSkill(2,'block')">
              <span class="skill-label">封鎖格子</span>
              <span class="skill-count" id="p2-block-count">x1</span>
            </button>
            <button id="p2-remove" class="skill p2-btn" onclick="useSkill(2,'remove')">
              <span class="skill-label">移除對方棋子</span>
              <span class="skill-count" id="p2-remove-count">x1</span>
            </button>
            <button id="p2-rotate" class="skill p2-btn" onclick="useRotateSkill(2)">
              <span class="skill-label">旋轉棋盤牌</span>
              <span class="skill-count" id="p2-rotate-count">x1</span>
            </button>
          </div>
        </div>
      </div>

      <div id="hint">
        提示：雙方各下完一次算一回合，每三回合棋盤會依目前方向自動旋轉 90 度並重力落到最底。每位玩家每回合只能使用一張技能牌。
      </div>

      <div id="actions">
        <button onclick="resetGame()">重新開始對戰</button>
      </div>

      <div id="stats">
        戰績統計：玩家 1 勝場 <span id="stats-p1">0</span>｜玩家 2 勝場 <span id="stats-p2">0</span>｜總對戰數 <span id="stats-total">0</span><br>
        目前最長連勝：<span id="stats-streak-player">尚無</span>（<span id="stats-streak-count">0</span> 連勝）
      </div>
    </div>
  </section>
</main>

<script>
const boardSize = 10;
const MOVE_TIME = 15; // 每手 15 秒
const MODE_PVP = 'pvp';
const MODE_AI = 'ai';

let board = [];
let currentPlayer = 1;
let pendingExtraMovePlayer = null; // 連續落子用
let mode = 'normal'; // 'normal' | 'block' | 'remove'
let skillOwner = null;
let timerId = null;
let timeLeft = MOVE_TIME;
let gameMode = MODE_PVP;
let hasStarted = false;

// 回合與旋轉
let roundCount = 0;                      // 已完成的回合數（雙方各動一次）
let movedThisRound = { 1:false, 2:false }; // 本回合內誰已動過
let usedCardThisRound = { 1:false, 2:false }; // 本回合卡牌使用限制
let autoRotateDir = 1;                   // 1: 順時針, -1: 逆時針
let boardRotSteps = 0;                   // 目前盤面旋轉了幾次 90°（0~3）

// 戰績
let stats = {
  p1Wins:0,
  p2Wins:0,
  draws:0,
  totalGames:0,
  longestStreak:0,
  currentStreakPlayer:null,
  currentStreakCount:0
};

const boardDiv = document.getElementById('board');
const turnDiv = document.getElementById('turn');
const timerDiv = document.getElementById('timer');
const hintDiv = document.getElementById('hint');
const p2Tag = document.getElementById('p2-tag');
const board3d = document.getElementById('board-3d');

function scrollToSection(id){
  document.getElementById(id).scrollIntoView({behavior:'smooth', block:'start'});
}

function initBoard() {
  board = Array(boardSize).fill().map(()=>Array(boardSize).fill(0));
  boardDiv.innerHTML = '';

  for (let r = 0; r < boardSize; r++) {
    for (let c = 0; c < boardSize; c++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.addEventListener('click', onCellClick);
      boardDiv.appendChild(cell);
    }
  }
}

function renderBoard() {
  for (let r = 0; r < boardSize; r++) {
    for (let c = 0; c < boardSize; c++) {
      const idx = r * boardSize + c;
      const cell = boardDiv.children[idx];
      cell.classList.remove('p1','p2','blocked','drop');
      if (board[r][c] === 1) cell.classList.add('p1');
      else if (board[r][c] === 2) cell.classList.add('p2');
      else if (board[r][c] === -1) cell.classList.add('blocked');
    }
  }
}

function startTimer() {
  clearInterval(timerId);
  timeLeft = MOVE_TIME;
  updateTimerText();
  timerId = setInterval(() => {
    timeLeft--;
    updateTimerText();
    if (timeLeft <= 0) {
      clearInterval(timerId);
      timerDiv.textContent = '時間到，自動落子中…';
      setTimeout(autoMoveOnTimeout, 400);
    }
  }, 1000);
}

function updateTimerText() {
  timerDiv.textContent = `剩餘時間：${timeLeft} 秒`;
}

function startGame() {
  if (hasStarted) return;
  hasStarted = true;
  timerDiv.textContent = `剩餘時間：${MOVE_TIME} 秒`;
  scheduleNextTurn();
}

function onCellClick(e) {
  const r = Number(e.target.dataset.r);
  const c = Number(e.target.dataset.c);

  if (!hasStarted) return;
  if (gameMode === MODE_AI && currentPlayer === 2) return; // AI 回合禁止玩家點擊

  if (mode === 'block') {
    handleBlockSkill(r, c, e.target);
    return;
  }
  if (mode === 'remove') {
    handleRemoveSkill(r, c, e.target);
    return;
  }

  handleMove(r, c, e.target);
}

function handleMove(r, c, cellEl) {
  if (board[r][c] !== 0) return; // 已有棋子或封鎖

  board[r][c] = currentPlayer;
  cellEl.classList.add(currentPlayer === 1 ? 'p1' : 'p2');
  cellEl.classList.add('drop');
  setTimeout(() => cellEl.classList.remove('drop'), 400);

  if (checkWin(r, c)) {
    const winner = currentPlayer;
    clearInterval(timerId);
    setTimeout(() => {
      finishGame(winner, `玩家 ${winner} 連成五子，勝利！`);
    }, 20);
    return;
  }

  if (isBoardFull()) {
    clearInterval(timerId);
    setTimeout(() => {
      finishGame(0, '棋盤已滿，本局平手！');
    }, 20);
    return;
  }

  // 記錄本回合誰已經行動過
  movedThisRound[currentPlayer] = true;

  // 連續落子判定
  if (pendingExtraMovePlayer === currentPlayer) {
    pendingExtraMovePlayer = null;
    hintDiv.textContent = '連續落子啟動：你還可以再下一手。';
    startTimer();
    return;
  }

  // 回合結算與自動旋轉
  const endedByRotation = maybeAdvanceRoundAndRotate();
  if (endedByRotation) {
    return; // 旋轉後直接結束遊戲
  }

  // 正常換手
  currentPlayer = currentPlayer === 1 ? 2 : 1;
  hintDiv.textContent = '輪到你時可選擇技能或直接落子。';
  updateUI();
  scheduleNextTurn();
}

function handleBlockSkill(r, c, cellEl) {
  if (board[r][c] !== 0) return; // 只能封鎖空格
  board[r][c] = -1; // -1 代表封鎖
  cellEl.classList.add('blocked');

  skills[skillOwner].block--;
  usedCardThisRound[skillOwner] = true;
  exitSkillMode();
}

function handleRemoveSkill(r, c, cellEl) {
  const opponent = skillOwner === 1 ? 2 : 1;
  if (board[r][c] !== opponent) return; // 只能移除對手棋子

  board[r][c] = 0;
  cellEl.classList.remove('p1','p2');

  skills[skillOwner].remove--;
  usedCardThisRound[skillOwner] = true;
  exitSkillMode();
}

function scheduleNextTurn() {
  if (!hasStarted) {
    timerDiv.textContent = '尚未開始：請按「開始遊戲」';
    return;
  }
  if (gameMode === MODE_AI && currentPlayer === 2) {
    clearInterval(timerId);
    timerDiv.textContent = 'AI 思考中…';
    setTimeout(aiMove, 400);
  } else {
    startTimer();
  }
}

// 技能邏輯
const skills = {
  1: { double: 1, block: 1, remove: 1, rotate: 1 },
  2: { double: 1, block: 1, remove: 1, rotate: 1 }
};

function useSkill(player, type) {
  if (player !== currentPlayer) return; // 非當前玩家不能用
  if (!hasStarted) return;
  if (skills[player][type] <= 0) return;
  if (mode !== 'normal') return; // 已在技能模式中
  if (usedCardThisRound[player]) {
    hintDiv.textContent = '本回合你已使用過一張技能牌，請等待下一回合。';
    return;
  }
  if (gameMode === MODE_AI && player === 2) return; // AI 不主動用技能

  if (type === 'double') {
    pendingExtraMovePlayer = player;
    skills[player].double--;
    usedCardThisRound[player] = true;
    hintDiv.textContent = '連續落子啟動！這回合你可以連下兩手。';
    updateUI();
    return;
  }

  // block / remove 需要點格子
  mode = type; // 'block' 或 'remove'
  skillOwner = player;
  if (type === 'block') {
    hintDiv.textContent = '封鎖格子：請點選任一尚未下子的格子。';
  } else if (type === 'remove') {
    hintDiv.textContent = '移除棋子：請點選對方的一顆棋子。';
  }
  updateUI();
}

function useRotateSkill(player) {
  if (player !== currentPlayer) return;
  if (!hasStarted) return;
  if (skills[player].rotate <= 0) return;
  if (mode !== 'normal') return;
  if (usedCardThisRound[player]) {
    hintDiv.textContent = '本回合你已使用過一張技能牌，請等待下一回合。';
    return;
  }
  if (gameMode === MODE_AI && player === 2) return; // 目前不讓 AI 用旋轉牌

  const cw = confirm('使用旋轉牌！\n按「確定」：順時針旋轉 90 度\n按「取消」：逆時針旋轉 90 度');
  const dir = cw ? 1 : -1;

  skills[player].rotate--;
  autoRotateDir = dir; // 之後每三回合自動旋轉會沿用這個方向
  usedCardThisRound[player] = true;
  updateSkillCounts();

  const ended = applyBoardRotation(dir);
  if (ended) return;

  hintDiv.textContent = dir === 1
    ? '你使用了順時針旋轉牌，之後每三回合會順時針旋轉 90 度並重力落到底。'
    : '你使用了逆時針旋轉牌，之後每三回合會逆時針旋轉 90 度並重力落到底。';
}

function exitSkillMode() {
  mode = 'normal';
  skillOwner = null;
  updateUI();
}

// AI 行為：簡易進攻 + 防守 + 隨機
function aiMove() {
  if (currentPlayer !== 2) return;

  let move = findWinningMove(2); // 先找 AI 自己的致勝點
  if (!move) move = findWinningMove(1); // 再試著擋住玩家致勝點
  if (!move) move = findRandomMove();

  if (!move) {
    finishGame(0, '棋盤已滿，本局平手！');
    return;
  }

  const [r, c] = move;
  const index = r * boardSize + c;
  const cellEl = boardDiv.children[index];
  handleMove(r, c, cellEl);
}

// 逾時自動落子
function autoMoveOnTimeout() {
  const move = findRandomMove();
  if (!move) {
    finishGame(0, '棋盤已滿，本局平手！');
    return;
  }
  const [r, c] = move;
  const index = r * boardSize + c;
  const cellEl = boardDiv.children[index];
  handleMove(r, c, cellEl);
}

function findWinningMove(player) {
  for (let r = 0; r < boardSize; r++) {
    for (let c = 0; c < boardSize; c++) {
      if (board[r][c] !== 0) continue;
      board[r][c] = player;
      const win = checkWin(r, c);
      board[r][c] = 0;
      if (win) return [r, c];
    }
  }
  return null;
}

function findRandomMove() {
  const empties = [];
  for (let r = 0; r < boardSize; r++) {
    for (let c = 0; c < boardSize; c++) {
      if (board[r][c] === 0) empties.push([r, c]);
    }
  }
  if (empties.length === 0) return null;
  const idx = Math.floor(Math.random() * empties.length);
  return empties[idx];
}

// 勝負與戰績
function checkWin(r, c) {
  const target = board[r][c];
  if (target !== 1 && target !== 2) return false;
  const dirs = [
    [[1,0],[-1,0]],
    [[0,1],[0,-1]],
    [[1,1],[-1,-1]],
    [[1,-1],[-1,1]]
  ];

  for (let dir of dirs) {
    let count = 1;
    for (let [dr, dc] of dir) {
      let nr = r + dr, nc = c + dc;
      while (nr>=0 && nr<boardSize && nc>=0 && nc<boardSize && board[nr][nc]===target) {
        count++;
        nr += dr; nc += dc;
      }
    }
    if (count >= 5) return true;
  }
  return false;
}

function isBoardFull() {
  for (let r = 0; r < boardSize; r++) {
    for (let c = 0; c < boardSize; c++) {
      if (board[r][c] === 0) return false;
    }
  }
  return true;
}

function finishGame(winner, message) {
  // 更新戰績
  stats.totalGames++;
  if (winner === 1) stats.p1Wins++;
  if (winner === 2) stats.p2Wins++;

  if (winner === 0) {
    stats.draws++;
    stats.currentStreakPlayer = null;
    stats.currentStreakCount = 0;
  } else {
    if (stats.currentStreakPlayer === winner) {
      stats.currentStreakCount++;
    } else {
      stats.currentStreakPlayer = winner;
      stats.currentStreakCount = 1;
    }
    if (stats.currentStreakCount > stats.longestStreak) {
      stats.longestStreak = stats.currentStreakCount;
    }
  }

  updateStatsUI();
  alert(message);
  resetGame(false); // 不重置戰績
}

function updateStatsUI() {
  document.getElementById('stats-p1').textContent = stats.p1Wins;
  document.getElementById('stats-p2').textContent = stats.p2Wins;
  document.getElementById('stats-total').textContent = stats.totalGames;

  if (!stats.currentStreakPlayer) {
    document.getElementById('stats-streak-player').textContent = '尚無';
    document.getElementById('stats-streak-count').textContent = '0';
  } else {
    document.getElementById('stats-streak-player').textContent = `玩家 ${stats.currentStreakPlayer}`;
    document.getElementById('stats-streak-count').textContent = stats.currentStreakCount;
  }
}

function resetGame(resetStats=true) {
  clearInterval(timerId);
  currentPlayer = 1;
  pendingExtraMovePlayer = null;
  mode = 'normal';
  skillOwner = null;

  roundCount = 0;
  movedThisRound = {1:false, 2:false};
  usedCardThisRound = {1:false, 2:false};
  autoRotateDir = 1;
  boardRotSteps = 0;
  updateBoardTransform();

  hasStarted = false;
  timerDiv.textContent = '尚未開始：請按「開始遊戲」';

  if (resetStats) {
    stats = { 
      p1Wins:0,
      p2Wins:0,
      draws:0,
      totalGames:0,
      longestStreak:0,
      currentStreakPlayer:null,
      currentStreakCount:0 
    };
  }
  skills[1] = { double:1, block:1, remove:1, rotate:1 };
  skills[2] = { double:1, block:1, remove:1, rotate:1 };
  updateSkillCounts();
  initBoard();
  updateUI();
  updateStatsUI();
}

function updateSkillCounts() {
  document.getElementById('p1-double-count').textContent = 'x' + skills[1].double;
  document.getElementById('p1-block-count').textContent  = 'x' + skills[1].block;
  document.getElementById('p1-remove-count').textContent = 'x' + skills[1].remove;
  document.getElementById('p1-rotate-count').textContent = 'x' + skills[1].rotate;

  document.getElementById('p2-double-count').textContent = 'x' + skills[2].double;
  document.getElementById('p2-block-count').textContent  = 'x' + skills[2].block;
  document.getElementById('p2-remove-count').textContent = 'x' + skills[2].remove;
  document.getElementById('p2-rotate-count').textContent = 'x' + skills[2].rotate;
}

function updateUI() {
  turnDiv.textContent = `輪到：玩家 ${currentPlayer} ${currentPlayer===1 ? '（藍）' : '（紅）'}`;
  updateSkillCounts();

  const isNormal = mode === 'normal';
  const p1Turn = currentPlayer === 1;
  const p2Turn = currentPlayer === 2;

  // 玩家 1 技能（每回合只能 1 張）
  document.getElementById('p1-double').disabled = !isNormal || !p1Turn || skills[1].double<=0 || usedCardThisRound[1];
  document.getElementById('p1-block').disabled  = !isNormal || !p1Turn || skills[1].block<=0  || usedCardThisRound[1];
  document.getElementById('p1-remove').disabled = !isNormal || !p1Turn || skills[1].remove<=0 || usedCardThisRound[1];
  document.getElementById('p1-rotate').disabled = !isNormal || !p1Turn || skills[1].rotate<=0 || usedCardThisRound[1];

  // 玩家 2 / AI 技能
  const isAI = gameMode === MODE_AI;
  document.getElementById('p2-double').disabled = !isNormal || !p2Turn || skills[2].double<=0 || usedCardThisRound[2] || isAI;
  document.getElementById('p2-block').disabled  = !isNormal || !p2Turn || skills[2].block<=0  || usedCardThisRound[2] || isAI;
  document.getElementById('p2-remove').disabled = !isNormal || !p2Turn || skills[2].remove<=0 || usedCardThisRound[2] || isAI;
  document.getElementById('p2-rotate').disabled = !isNormal || !p2Turn || skills[2].rotate<=0 || usedCardThisRound[2] || isAI;

  p2Tag.textContent = isAI ? 'AI（紅方）' : '紅方';
}

function changeMode(value) {
  gameMode = value === MODE_AI ? MODE_AI : MODE_PVP;
  hintDiv.textContent = gameMode === MODE_AI
    ? '目前為「對 AI 對戰」模式：你是玩家 1，AI 是玩家 2。雙方各下完一次算一回合，每三回合依目前方向自動旋轉 90 度並重力落到底。'
    : '目前為「雙人對戰」模式：雙方各下完一次算一回合，每三回合依目前方向自動旋轉 90 度並重力落到底。';
  resetGame(true);
}

// --- 回合與旋轉相關 ---

function maybeAdvanceRoundAndRotate() {
  if (movedThisRound[1] && movedThisRound[2]) {
    roundCount++;
    movedThisRound[1] = false;
    movedThisRound[2] = false;
    usedCardThisRound[1] = false;
    usedCardThisRound[2] = false;

    if (roundCount % 3 === 0) {
      // 每三回合自動旋轉
      const ended = applyBoardRotation(autoRotateDir);
      if (ended) return true;
    }
  }
  return false;
}

function rotateMatrixOnce(b, dir) {
  const n = boardSize;
  const nb = Array(n).fill().map(()=>Array(n).fill(0));
  if (dir === 1) {
    // 順時針：new[r][c] = old[n-1-c][r]
    for (let r=0; r<n; r++) {
      for (let c=0; c<n; c++) {
        nb[r][c] = b[n-1-c][r];
      }
    }
  } else {
    // 逆時針：new[r][c] = old[c][n-1-r]
    for (let r=0; r<n; r++) {
      for (let c=0; c<n; c++) {
        nb[r][c] = b[c][n-1-r];
      }
    }
  }
  return nb;
}

// 重力：棋子落到底（封鎖格 -1 不會動）
function applyGravityDropAll() {
  for (let c = 0; c < boardSize; c++) {
    let write = boardSize - 1;
    for (let r = boardSize - 1; r >= 0; r--) {
      if (board[r][c] === -1) {
        write = r - 1; // 障礙，下方寫入位置跳到障礙上方
      } else if (board[r][c] === 1 || board[r][c] === 2) {
        if (write !== r) {
          board[write][c] = board[r][c];
          board[r][c] = 0;
        }
        write--;
      }
    }
  }
}

// 旋轉 + 重力 + 檢查是否因旋轉而直接有人連成五子
function applyBoardRotation(dir) {
  board = rotateMatrixOnce(board, dir);
  applyGravityDropAll();
  renderBoard();

  boardRotSteps = (boardRotSteps + (dir === 1 ? 1 : -1) + 4) % 4;
  updateBoardTransform();

  // 檢查是否因旋轉造成五子
  return checkAnyWinAfterRotation();
}

function updateBoardTransform() {
  if (!board3d) return;
  const angle = boardRotSteps * 90;
  board3d.style.transform = `rotate(${angle}deg)`;
}

function checkAnyWinAfterRotation() {
  let p1Win = false;
  let p2Win = false;

  for (let r = 0; r < boardSize; r++) {
    for (let c = 0; c < boardSize; c++) {
      if (board[r][c] === 1 && checkWin(r,c)) p1Win = true;
      else if (board[r][c] === 2 && checkWin(r,c)) p2Win = true;
    }
  }

  if (!p1Win && !p2Win) return false;

  let winner, msg;
  if (p1Win && !p2Win) {
    winner = 1;
    msg = '棋盤旋轉與重力落子後，玩家 1 形成五子連線，勝利！';
  } else if (!p1Win && p2Win) {
    winner = 2;
    msg = '棋盤旋轉與重力落子後，玩家 2 形成五子連線，勝利！';
  } else {
    winner = 0;
    msg = '棋盤旋轉與重力落子後，雙方同時形成五子連線，本局平手！';
  }

  clearInterval(timerId);
  finishGame(winner, msg);
  return true;
}

// 初始化
initBoard();
updateBoardTransform();
updateUI();
updateStatsUI();
</script>
</body>
</html>
